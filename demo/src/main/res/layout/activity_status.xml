<?xml version="1.0" encoding="utf-8"?>
<me.ibore.widget.RootLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >

    <me.ibore.widget.XNestedScrollView
        android:id="@+id/nestedScrollView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical"
        app:layout_rootType="content">

        <TextView
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:padding="15dp"
            android:text="按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中，所以肯定是局部加载，那么就需要用到一个类
BitmapRegionDecoder，还要实现手势检测，然后根据手势计算加载矩形的上下左右的值，在onDrow中进行绘制。
这个例子实现的功能：如果图片的宽度比手机屏幕的宽度窄，计算一个缩放比例，在绘制的时候，对图片进行放大，是图片宽度与手机屏幕宽度一致。如果图片的宽度比手机屏幕的宽度大，缩放系数就为1f。

作者：migill
链接：https://www.jianshu.com/p/8fa22d04d48b
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中，所以肯定是局部加载，那么就需要用到一个类
BitmapRegionDecoder，还要实现手势检测，然后根据手势计算加载矩形的上下左右的值，在onDrow中进行绘制。
这个例子实现的功能：如果图片的宽度比手机屏幕的宽度窄，计算一个缩放比例，在绘制的时候，对图片进行放大，是图片宽度与手机屏幕宽度一致。如果图片的宽度比手机屏幕的宽度大，缩放系数就为1f。

作者：migill
链接：https://www.jianshu.com/p/8fa22d04d48b
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中，所以肯定是局部加载，那么就需要用到一个类
BitmapRegionDecoder，还要实现手势检测，然后根据手势计算加载矩形的上下左右的值，在onDrow中进行绘制。
这个例子实现的功能：如果图片的宽度比手机屏幕的宽度窄，计算一个缩放比例，在绘制的时候，对图片进行放大，是图片宽度与手机屏幕宽度一致。如果图片的宽度比手机屏幕的宽度大，缩放系数就为1f。

作者：migill
链接：https://www.jianshu.com/p/8fa22d04d48b
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中，所以肯定是局部加载，那么就需要用到一个类
BitmapRegionDecoder，还要实现手势检测，然后根据手势计算加载矩形的上下左右的值，在onDrow中进行绘制。
这个例子实现的功能：如果图片的宽度比手机屏幕的宽度窄，计算一个缩放比例，在绘制的时候，对图片进行放大，是图片宽度与手机屏幕宽度一致。如果图片的宽度比手机屏幕的宽度大，缩放系数就为1f。

作者：migill
链接：https://www.jianshu.com/p/8fa22d04d48b
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中，所以肯定是局部加载，那么就需要用到一个类
BitmapRegionDecoder，还要实现手势检测，然后根据手势计算加载矩形的上下左右的值，在onDrow中进行绘制。
这个例子实现的功能：如果图片的宽度比手机屏幕的宽度窄，计算一个缩放比例，在绘制的时候，对图片进行放大，是图片宽度与手机屏幕宽度一致。如果图片的宽度比手机屏幕的宽度大，缩放系数就为1f。

作者：migill
链接：https://www.jianshu.com/p/8fa22d04d48b
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中，所以肯定是局部加载，那么就需要用到一个类
BitmapRegionDecoder，还要实现手势检测，然后根据手势计算加载矩形的上下左右的值，在onDrow中进行绘制。
这个例子实现的功能：如果图片的宽度比手机屏幕的宽度窄，计算一个缩放比例，在绘制的时候，对图片进行放大，是图片宽度与手机屏幕宽度一致。如果图片的宽度比手机屏幕的宽度大，缩放系数就为1f。

作者：migill
链接：https://www.jianshu.com/p/8fa22d04d48b
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中，所以肯定是局部加载，那么就需要用到一个类
BitmapRegionDecoder，还要实现手势检测，然后根据手势计算加载矩形的上下左右的值，在onDrow中进行绘制。
这个例子实现的功能：如果图片的宽度比手机屏幕的宽度窄，计算一个缩放比例，在绘制的时候，对图片进行放大，是图片宽度与手机屏幕宽度一致。如果图片的宽度比手机屏幕的宽度大，缩放系数就为1f。

作者：migill
链接：https://www.jianshu.com/p/8fa22d04d48b
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中，所以肯定是局部加载，那么就需要用到一个类
BitmapRegionDecoder，还要实现手势检测，然后根据手势计算加载矩形的上下左右的值，在onDrow中进行绘制。
这个例子实现的功能：如果图片的宽度比手机屏幕的宽度窄，计算一个缩放比例，在绘制的时候，对图片进行放大，是图片宽度与手机屏幕宽度一致。如果图片的宽度比手机屏幕的宽度大，缩放系数就为1f。

作者：migill
链接：https://www.jianshu.com/p/8fa22d04d48b
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中，所以肯定是局部加载，那么就需要用到一个类
BitmapRegionDecoder，还要实现手势检测，然后根据手势计算加载矩形的上下左右的值，在onDrow中进行绘制。
这个例子实现的功能：如果图片的宽度比手机屏幕的宽度窄，计算一个缩放比例，在绘制的时候，对图片进行放大，是图片宽度与手机屏幕宽度一致。如果图片的宽度比手机屏幕的宽度大，缩放系数就为1f。

作者：migill
链接：https://www.jianshu.com/p/8fa22d04d48b
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中，所以肯定是局部加载，那么就需要用到一个类
BitmapRegionDecoder，还要实现手势检测，然后根据手势计算加载矩形的上下左右的值，在onDrow中进行绘制。
这个例子实现的功能：如果图片的宽度比手机屏幕的宽度窄，计算一个缩放比例，在绘制的时候，对图片进行放大，是图片宽度与手机屏幕宽度一致。如果图片的宽度比手机屏幕的宽度大，缩放系数就为1f。

作者：migill
链接：https://www.jianshu.com/p/8fa22d04d48b
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中，所以肯定是局部加载，那么就需要用到一个类
BitmapRegionDecoder，还要实现手势检测，然后根据手势计算加载矩形的上下左右的值，在onDrow中进行绘制。
这个例子实现的功能：如果图片的宽度比手机屏幕的宽度窄，计算一个缩放比例，在绘制的时候，对图片进行放大，是图片宽度与手机屏幕宽度一致。如果图片的宽度比手机屏幕的宽度大，缩放系数就为1f。

作者：migill
链接：https://www.jianshu.com/p/8fa22d04d48b
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中，所以肯定是局部加载，那么就需要用到一个类
BitmapRegionDecoder，还要实现手势检测，然后根据手势计算加载矩形的上下左右的值，在onDrow中进行绘制。
这个例子实现的功能：如果图片的宽度比手机屏幕的宽度窄，计算一个缩放比例，在绘制的时候，对图片进行放大，是图片宽度与手机屏幕宽度一致。如果图片的宽度比手机屏幕的宽度大，缩放系数就为1f。

作者：migill
链接：https://www.jianshu.com/p/8fa22d04d48b
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中，所以肯定是局部加载，那么就需要用到一个类
BitmapRegionDecoder，还要实现手势检测，然后根据手势计算加载矩形的上下左右的值，在onDrow中进行绘制。
这个例子实现的功能：如果图片的宽度比手机屏幕的宽度窄，计算一个缩放比例，在绘制的时候，对图片进行放大，是图片宽度与手机屏幕宽度一致。如果图片的宽度比手机屏幕的宽度大，缩放系数就为1f。

作者：migill
链接：https://www.jianshu.com/p/8fa22d04d48b
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中，所以肯定是局部加载，那么就需要用到一个类
BitmapRegionDecoder，还要实现手势检测，然后根据手势计算加载矩形的上下左右的值，在onDrow中进行绘制。
这个例子实现的功能：如果图片的宽度比手机屏幕的宽度窄，计算一个缩放比例，在绘制的时候，对图片进行放大，是图片宽度与手机屏幕宽度一致。如果图片的宽度比手机屏幕的宽度大，缩放系数就为1f。

作者：migill
链接：https://www.jianshu.com/p/8fa22d04d48b
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中，所以肯定是局部加载，那么就需要用到一个类
BitmapRegionDecoder，还要实现手势检测，然后根据手势计算加载矩形的上下左右的值，在onDrow中进行绘制。
这个例子实现的功能：如果图片的宽度比手机屏幕的宽度窄，计算一个缩放比例，在绘制的时候，对图片进行放大，是图片宽度与手机屏幕宽度一致。如果图片的宽度比手机屏幕的宽度大，缩放系数就为1f。

作者：migill
链接：https://www.jianshu.com/p/8fa22d04d48b
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中，所以肯定是局部加载，那么就需要用到一个类
BitmapRegionDecoder，还要实现手势检测，然后根据手势计算加载矩形的上下左右的值，在onDrow中进行绘制。
这个例子实现的功能：如果图片的宽度比手机屏幕的宽度窄，计算一个缩放比例，在绘制的时候，对图片进行放大，是图片宽度与手机屏幕宽度一致。如果图片的宽度比手机屏幕的宽度大，缩放系数就为1f。

作者：migill
链接：https://www.jianshu.com/p/8fa22d04d48b
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中，所以肯定是局部加载，那么就需要用到一个类
BitmapRegionDecoder，还要实现手势检测，然后根据手势计算加载矩形的上下左右的值，在onDrow中进行绘制。
这个例子实现的功能：如果图片的宽度比手机屏幕的宽度窄，计算一个缩放比例，在绘制的时候，对图片进行放大，是图片宽度与手机屏幕宽度一致。如果图片的宽度比手机屏幕的宽度大，缩放系数就为1f。

作者：migill
链接：https://www.jianshu.com/p/8fa22d04d48b
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中，所以肯定是局部加载，那么就需要用到一个类
BitmapRegionDecoder，还要实现手势检测，然后根据手势计算加载矩形的上下左右的值，在onDrow中进行绘制。
这个例子实现的功能：如果图片的宽度比手机屏幕的宽度窄，计算一个缩放比例，在绘制的时候，对图片进行放大，是图片宽度与手机屏幕宽度一致。如果图片的宽度比手机屏幕的宽度大，缩放系数就为1f。

作者：migill
链接：https://www.jianshu.com/p/8fa22d04d48b
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中，所以肯定是局部加载，那么就需要用到一个类
BitmapRegionDecoder，还要实现手势检测，然后根据手势计算加载矩形的上下左右的值，在onDrow中进行绘制。
这个例子实现的功能：如果图片的宽度比手机屏幕的宽度窄，计算一个缩放比例，在绘制的时候，对图片进行放大，是图片宽度与手机屏幕宽度一致。如果图片的宽度比手机屏幕的宽度大，缩放系数就为1f。

作者：migill
链接：https://www.jianshu.com/p/8fa22d04d48b
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。" />

    </me.ibore.widget.XNestedScrollView>


    <me.ibore.widget.TitleBar
        android:id="@+id/title_bar"
        style="@style/TitleBar">

        <include layout="@layout/title_bar" />

    </me.ibore.widget.TitleBar>

</me.ibore.widget.RootLayout>